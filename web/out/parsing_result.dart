// Auto-generated from parsing_results.html.
// DO NOT EDIT.

library parsing_result;

import 'dart:html' as autogenerated_html;
import 'dart:web_audio' as autogenerated_audio;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;

import 'package:web_ui/web_ui.dart';

import 'package:dartlr/dartlr_client.dart';

import 'dart:html';

import 'package:js/js.dart' as js;

class ErrorInfo {
  final int line;
  final int col;
  final String message;
  ErrorInfo(this.line, this.col, this.message);
}

class ParsingResult extends WebComponent {
  
  /** Autogenerated from the template. */
  
  /**
  * Shadow root for this component. We use 'var' to allow simulating shadow DOM
  * on browsers that don't support this feature.
  */
  var _root;
  autogenerated_html.DivElement __e10;
  
  List<autogenerated.WatcherDisposer> __stoppers1;
  
  autogenerated_html.UnknownElement __e0;
  
  autogenerated_html.Node _endPosition__e0;
  
  bool _isVisible__e0 = false;
  
  autogenerated_html.UnknownElement __e9;
  
  autogenerated_html.Node _endPosition__e9;
  
  bool _isVisible__e9 = false;
  
  autogenerated_html.UListElement __e8;
  
  autogenerated_html.UnknownElement __e7;
  
  List<autogenerated.WatcherDisposer> __stoppers2_1;
  
  List<Function> _removeChild__e7 = [];
  
  autogenerated_html.Node _endPosition__e7;
  
  ParsingResult.forElement(e) : super.forElement(e);
  
  void created_autogenerated() {
    _root = createShadowRoot();
    
    _root.innerHtml = '''
    
    <div class="" id="__e-10">
    <template id="__e-0" style="display:none"></template>
    <template id="__e-9" style="display:none"></template>
    </div>
    ''';
    __e10 = _root.query('#__e-10');
    __e0 = __e10.query('#__e-0');
    __e9 = __e10.query('#__e-9');
    __stoppers1 = [];
    
  }
  
  void inserted_autogenerated() {
    __stoppers1.add(autogenerated.bindCssClasses(__e10, () => classes));
    
    _endPosition__e0 = __e0;
    
    __stoppers1.add(autogenerated.watchAndInvoke(() => errors.isEmpty, (__e) {
      bool showNow = __e.newValue;
      if (_isVisible__e0 && !showNow) {
        _isVisible__e0 = false;
        
        _endPosition__e0 = autogenerated.removeNodes(__e0, _endPosition__e0);
        
      } else if (!_isVisible__e0 && showNow) {
        
        _isVisible__e0 = true;
        
        autogenerated.insertAllBefore(__e0.parentNode, __e0.nextNode,
        
        [_endPosition__e0 = new autogenerated_html.Text('\n             Parsing OK\n           ')]);
        
      }
    }));
    
    _endPosition__e9 = __e9;
    
    __stoppers1.add(autogenerated.watchAndInvoke(() => !errors.isEmpty, (__e) {
      bool showNow = __e.newValue;
      if (_isVisible__e9 && !showNow) {
        _isVisible__e9 = false;
        
        __e8 = null;
        (__stoppers2_1..forEach((s) => s())).clear();
        _endPosition__e7 = autogenerated.removeNodes(__e7, _endPosition__e7);
        for (var remover in _removeChild__e7) remover();
        _removeChild__e7.clear();
        
        __e7 = null;
        
        _endPosition__e9 = autogenerated.removeNodes(__e9, _endPosition__e9);
        
      } else if (!_isVisible__e9 && showNow) {
        
        _isVisible__e9 = true;
        
        __e8 = new autogenerated_html.Element.html('<ul>\n                <template id="__e-7" style="display:none"></template>               \n             </ul>');
        __e7 = __e8.query('#__e-7');
        __stoppers2_1 = [];
        
        autogenerated.insertAllBefore(__e9.parentNode, __e9.nextNode,
        
        [new autogenerated_html.Text('\n             Parsing failed with the following errors:\n             '), __e8, _endPosition__e9 = new autogenerated_html.Text('\n           ')]);
        
        _endPosition__e7 = __e7;
        __stoppers2_1.add(autogenerated.watchAndInvoke(() => errors, (_) {
          for (var remover in _removeChild__e7) remover();
          _removeChild__e7.clear();
          
          _endPosition__e7 = autogenerated.removeNodes(__e7, _endPosition__e7);
          var __insert___e7 = __e7.nextNode;
          for (var error in errors) {
            autogenerated_html.LIElement __e6;
            autogenerated_html.AnchorElement __e3;
            autogenerated_html.EventListener __listener__e3_click_3_2_1;
            var __binding1;
            List<autogenerated.WatcherDisposer> __stoppers4_3_2;
            var __binding2;
            autogenerated_html.SpanElement __e5;
            var __binding4;
            __e6 = new autogenerated_html.Element.html('<li><a class="parse-error-position" id="__e-3"></a> <span class="parse-error-text" id="__e-5"></span></li>');
            __e3 = __e6.query('#__e-3');
            __binding1 = new autogenerated_html.Text('');
            __stoppers4_3_2 = [];
            __binding2 = new autogenerated_html.Text('');
            __e3.nodes.add(new autogenerated_html.Text('('));
            __e3.nodes.add(__binding1);
            __e3.nodes.add(new autogenerated_html.Text(', '));
            __e3.nodes.add(__binding2);
            __e3.nodes.add(new autogenerated_html.Text(')'));
            __e5 = __e6.query('#__e-5');
            __binding4 = new autogenerated_html.Text('');
            __e5.nodes.add(__binding4);
            autogenerated.insertAllBefore(__e7.parentNode, __insert___e7,
            [new autogenerated_html.Text('\n                  '), __e6, _endPosition__e7 = new autogenerated_html.Text('\n                ')]);
            __listener__e3_click_3_2_1 = ($event) {
              navigateToError(error.line, error.col);
              autogenerated.dispatch();
            };
            __e3.on.click.add(__listener__e3_click_3_2_1);
            
            __stoppers4_3_2.add(autogenerated.watchAndInvoke(() => '${error.line}', (__e) {
              __binding1 = autogenerated.updateBinding(error.line, __binding1, __e.newValue);
            }));
            __stoppers4_3_2.add(autogenerated.watchAndInvoke(() => '${error.col}', (__e) {
              __binding2 = autogenerated.updateBinding(error.col, __binding2, __e.newValue);
            }));
            __stoppers4_3_2.add(autogenerated.watchAndInvoke(() => '${error.message}', (__e) {
              __binding4 = autogenerated.updateBinding(error.message, __binding4, __e.newValue);
            }));
            _removeChild__e7.add(() {
              __e6 = null;
              __e3.on.click.remove(__listener__e3_click_3_2_1);
              __listener__e3_click_3_2_1 = null;
              
              __e3 = null;
              (__stoppers4_3_2..forEach((s) => s())).clear();
              __binding1 = null;
              __binding2 = null;
              __e5 = null;
              __binding4 = null;
            });
          }
        }));
        
      }
    }));
    
  }
  
  void removed_autogenerated() {
    _root = null;
    
    (__stoppers1..forEach((s) => s())).clear();
    
    __e10 = null;
    
    if (_isVisible__e0) {
      
      _endPosition__e0 = autogenerated.removeNodes(__e0, _endPosition__e0);
      
    }
    
    __e0 = null;
    
    if (_isVisible__e9) {
      
      _endPosition__e9 = autogenerated.removeNodes(__e9, _endPosition__e9);
      
      __e8 = null;
      (__stoppers2_1..forEach((s) => s())).clear();
      _endPosition__e7 = autogenerated.removeNodes(__e7, _endPosition__e7);
      for (var remover in _removeChild__e7) remover();
      _removeChild__e7.clear();
      
      __e7 = null;
      
    }
    
    __e9 = null;
    
  }
  
  void composeChildren() {
    super.composeChildren();
    if (_root is! autogenerated_html.ShadowRoot) _root = this;
  }
  
  /** Original code from the component. */
  
  var _editor;
  
  List<ErrorInfo> errors = [];
  
  set editor(editor) => _editor = editor;
  get editor {
    if (_editor == null) throw new StateError("editor is null. You have to inject it first.");
    return _editor;
  }
  
  /**
  * Navigates to the error position ([line], [col]) in the editor.
  */
  navigateToError(int line, int col) {
    js.scoped(() {
      editor.setCursor(line,col);
      editor.scrollIntoView(js.map({"line": line, "col" : col}));
      editor.focus();
    });
  }
  
  /**
  * Renders OK status after stylesheet parsing
  */
  renderOK() {
    this.errors = [];
  }
  
  /**
  * Renders parse errors after style sheet parsing.
  *
  * [errors] is either a single [RecognitionException] or a list thereof. Any other
  * value results in an [ArgumentError].
  */
  renderParseErrors(errors) {
    if (errors is RecognitionException) {
      errors = [errors];
    } else if (errors is List) {
      // OK
    } else {
      throw new ArgumentError("expect RecognitionException or list thereof, got $errors");
    }
    this.errors = errors.map((RecognitionException error) {
      var line = error.line;
      var col = error.charPositionInLine;
      var message = error.toString();
      return new ErrorInfo(line,col, message);
    });
  }
  
  List<String> get classes {
    if (errors.isEmpty) return ["alert", "alert-info"];
    else return ["alert", "alert-error"];
  }
}

